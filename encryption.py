import os, base64
from typing import Iterable

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# ============== Configurations ===============
SALT_SIZE = 16                            # bytes for salt in HKDF
NONCE_SIZE = 12                           # bytes for AES-GCM nonce
DEK_LEN = 32                              # 32 bytes -> AES-256
MASTER_KEY_ENV_VAR = "KEK"                # name of the environment variable by default
HKDF_INFO_PREFIX = b"likebot-secret-v1:"  # context (helps to differentiate secret types)
# Well-known encryption purposes to avoid mismatches across the codebase
PURPOSE_STRING_SESSION = b"StringSession"
PURPOSE_PASSWORD = b"Password"

# Legacy purpose aliases â€“ keep to decrypt older payloads that used different markers
_LEGACY_PURPOSES: dict[bytes, tuple[bytes, ...]] = {
    PURPOSE_STRING_SESSION: (b"Session",),
}
# =============================================


def _normalize_purpose(purpose: bytes | str) -> bytes:
    """Ensure the purpose value is represented as bytes."""
    if isinstance(purpose, bytes):
        return purpose
    if isinstance(purpose, str):
        return purpose.encode("utf-8")
    raise TypeError("purpose must be bytes or str")

def generate_master_key_base64() -> str:
    """Generate a new master key (32 bytes) and return it as base64 (for easy storage in env)."""
    key = os.urandom(32)
    return base64.urlsafe_b64encode(key).decode("ascii")


def set_master_key_in_process(kek_base64: str, env_var: str = MASTER_KEY_ENV_VAR) -> None:
    """
    Putting master key in os.environ only for the current process.
    For permanent storage use export in shell or secret manager.
    """
    os.environ[env_var] = kek_base64


def get_master_key_bytes_from_env(env_var: str = MASTER_KEY_ENV_VAR) -> bytes:
    """Get master key from environment variable (base64) and decode to bytes. Raises error if not found."""
    b64 = os.environ.get(env_var)
    if not b64:
        raise RuntimeError(f"Master key not found in environment variable '{env_var}'")
    return base64.urlsafe_b64decode(b64.encode("ascii"))


def _derive_dek(master_key: bytes, salt: bytes, purpose: bytes) -> bytes:
    """
    Derive a unique DEK from the master key and salt using HKDF.
    'purpose' differentiates the secret type (e.g. b'StringSession' or b'Password').
    """
    info = HKDF_INFO_PREFIX + purpose
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=DEK_LEN,
        salt=salt,
        info=info,
    )
    return hkdf.derive(master_key)


def encrypt_secret(
    plaintext: str,
    purpose: bytes | str = PURPOSE_STRING_SESSION,
    master_key_env_var: str = MASTER_KEY_ENV_VAR,
) -> str:
    """
    Return base64url string containing (salt || nonce || ciphertext).
    purpose - byte marker, to differentiate the secret type when deriving DEK.
    """
    purpose_bytes = _normalize_purpose(purpose)
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    salt = os.urandom(SALT_SIZE)
    dek = _derive_dek(master_key, salt, purpose_bytes)
    aesgcm = AESGCM(dek)
    nonce = os.urandom(NONCE_SIZE)
    ct = aesgcm.encrypt(nonce=nonce, data=plaintext.encode("utf-8"), associated_data=None)
    payload = salt + nonce + ct
    return base64.urlsafe_b64encode(payload).decode("ascii")


def decrypt_secret(
    token_b64: str,
    purpose: bytes | str = PURPOSE_STRING_SESSION,
    master_key_env_var: str = MASTER_KEY_ENV_VAR,
) -> str:
    """
    Decrypts a string generated by encrypt_secret. Returns plain text.
    """
    purpose_bytes = _normalize_purpose(purpose)
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    payload = base64.urlsafe_b64decode(token_b64.encode("ascii"))
    if len(payload) < (SALT_SIZE + NONCE_SIZE + 1):
        raise ValueError("Invalid token length")
    salt = payload[:SALT_SIZE]
    nonce = payload[SALT_SIZE:SALT_SIZE + NONCE_SIZE]
    ct = payload[SALT_SIZE + NONCE_SIZE:]
    purposes_to_try: Iterable[bytes] = (purpose_bytes,) + _LEGACY_PURPOSES.get(purpose_bytes, tuple())

    last_error: InvalidTag | None = None
    for current_purpose in purposes_to_try:
        try:
            dek = _derive_dek(master_key, salt, current_purpose)
            aesgcm = AESGCM(dek)
            pt = aesgcm.decrypt(nonce=nonce, data=ct, associated_data=None)
            return pt.decode("utf-8")
        except InvalidTag as err:
            last_error = err

    raise InvalidTag(
        "Decryption failed; verify that the master key and purpose match the encrypted secret."
    ) from last_error



# ========== DEMO ==========
if __name__ == "__main__":    
    print("New master key (put this into your env):", end=" ")  # Generate a new master key (one-time) and manually add it to the environment:
    demo_master_key = generate_master_key_base64()
    print(demo_master_key)    
    set_master_key_in_process(demo_master_key)

    secret = "1BQ:ABCDEFG... (example StringSession)"
    print("Original:", secret)
    
    encrypted = encrypt_secret(secret, purpose=PURPOSE_STRING_SESSION)
    print("Encrypted:", encrypted)

    decrypted = decrypt_secret(encrypted, purpose=PURPOSE_STRING_SESSION)
    print("Decrypted:", decrypted)
