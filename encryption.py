import os, base64
from typing import Iterable, Optional
from datetime import datetime, timedelta, timezone

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

import bcrypt
from jose import JWTError, jwt

# ============== Configurations ===============
SALT_SIZE = 16                            # bytes for salt in HKDF
NONCE_SIZE = 12                           # bytes for AES-GCM nonce
DEK_LEN = 32                              # 32 bytes -> AES-256
MASTER_KEY_ENV_VAR = "KEK"                # name of the environment variable by default
HKDF_INFO_PREFIX = b"likebot-secret-v1:"  # context (helps to differentiate secret types)
# Well-known encryption purposes to avoid mismatches across the codebase
PURPOSE_STRING_SESSION = b"StringSession"
PURPOSE_PASSWORD = b"Password"

# Legacy purpose aliases â€“ keep to decrypt older payloads that used different markers
_LEGACY_PURPOSES: dict[bytes, tuple[bytes, ...]] = {
    PURPOSE_STRING_SESSION: (b"Session",),
}

# JWT Configuration
JWT_SECRET_KEY_ENV_VAR = "JWT_SECRET_KEY"  # Environment variable for JWT secret
JWT_ALGORITHM = "HS256"
JWT_ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 days default

# =============================================


def _normalize_purpose(purpose: bytes | str) -> bytes:
    """Ensure the purpose value is represented as bytes."""
    if isinstance(purpose, bytes):
        return purpose
    if isinstance(purpose, str):
        return purpose.encode("utf-8")
    raise TypeError("purpose must be bytes or str")

def generate_master_key_base64() -> str:
    """Generate a new master key (32 bytes) and return it as base64 (for easy storage in env)."""
    key = os.urandom(32)
    return base64.urlsafe_b64encode(key).decode("ascii")


def set_master_key_in_process(kek_base64: str, env_var: str = MASTER_KEY_ENV_VAR) -> None:
    """
    Putting master key in os.environ only for the current process.
    For permanent storage use export in shell or secret manager.
    """
    os.environ[env_var] = kek_base64


def get_master_key_bytes_from_env(env_var: str = MASTER_KEY_ENV_VAR) -> bytes:
    """Get master key from environment variable (base64) and decode to bytes. Raises error if not found."""
    b64 = os.environ.get(env_var)
    if not b64:
        raise RuntimeError(f"Master key not found in environment variable '{env_var}'")
    return base64.urlsafe_b64decode(b64.encode("ascii"))


def _derive_dek(master_key: bytes, salt: bytes, purpose: bytes) -> bytes:
    """
    Derive a unique DEK from the master key and salt using HKDF.
    'purpose' differentiates the secret type (e.g. b'StringSession' or b'Password').
    """
    info = HKDF_INFO_PREFIX + purpose
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=DEK_LEN,
        salt=salt,
        info=info,
    )
    return hkdf.derive(master_key)


def encrypt_secret(
    plaintext: str,
    purpose: bytes | str = PURPOSE_STRING_SESSION,
    master_key_env_var: str = MASTER_KEY_ENV_VAR,
) -> str:
    """
    Return base64url string containing (salt || nonce || ciphertext).
    purpose - byte marker, to differentiate the secret type when deriving DEK.
    """
    purpose_bytes = _normalize_purpose(purpose)
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    salt = os.urandom(SALT_SIZE)
    dek = _derive_dek(master_key, salt, purpose_bytes)
    aesgcm = AESGCM(dek)
    nonce = os.urandom(NONCE_SIZE)
    ct = aesgcm.encrypt(nonce=nonce, data=plaintext.encode("utf-8"), associated_data=None)
    payload = salt + nonce + ct
    return base64.urlsafe_b64encode(payload).decode("ascii")


def decrypt_secret(
    token_b64: str,
    purpose: bytes | str = PURPOSE_STRING_SESSION,
    master_key_env_var: str = MASTER_KEY_ENV_VAR,
) -> str:
    """
    Decrypts a string generated by encrypt_secret. Returns plain text.
    """
    purpose_bytes = _normalize_purpose(purpose)
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    payload = base64.urlsafe_b64decode(token_b64.encode("ascii"))
    if len(payload) < (SALT_SIZE + NONCE_SIZE + 1):
        raise ValueError("Invalid token length")
    salt = payload[:SALT_SIZE]
    nonce = payload[SALT_SIZE:SALT_SIZE + NONCE_SIZE]
    ct = payload[SALT_SIZE + NONCE_SIZE:]
    purposes_to_try: Iterable[bytes] = (purpose_bytes,) + _LEGACY_PURPOSES.get(purpose_bytes, tuple())

    last_error: InvalidTag | None = None
    for current_purpose in purposes_to_try:
        try:
            dek = _derive_dek(master_key, salt, current_purpose)
            aesgcm = AESGCM(dek)
            pt = aesgcm.decrypt(nonce=nonce, data=ct, associated_data=None)
            return pt.decode("utf-8")
        except InvalidTag as err:
            last_error = err

    raise InvalidTag(
        "Decryption failed; verify that the master key and purpose match the encrypted secret."
    ) from last_error


# ============== PASSWORD HASHING ==============

def hash_password(password: str) -> str:
    """
    Hash a password using bcrypt.
    Bcrypt has a maximum password length of 72 bytes, so we truncate if necessary.
    
    Args:
        password: Plain text password
        
    Returns:
        Hashed password string
    """
    # Bcrypt has a 72-byte limit, so we truncate the password if needed
    password_bytes = password.encode('utf-8')
    if len(password_bytes) > 72:
        password_bytes = password_bytes[:72]
    
    # Generate salt and hash the password
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password_bytes, salt)
    
    # Return as a string
    return hashed.decode('utf-8')


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a password against its hash.
    Bcrypt has a maximum password length of 72 bytes, so we truncate if necessary.
    
    Args:
        plain_password: Plain text password to verify
        hashed_password: Hashed password to compare against
        
    Returns:
        True if password matches, False otherwise
    """
    # Bcrypt has a 72-byte limit, so we truncate the password if needed
    password_bytes = plain_password.encode('utf-8')
    if len(password_bytes) > 72:
        password_bytes = password_bytes[:72]
    
    # Convert hash to bytes if it's a string
    if isinstance(hashed_password, str):
        hashed_password = hashed_password.encode('utf-8')
    
    # Verify the password
    return bcrypt.checkpw(password_bytes, hashed_password)


# ============== JWT TOKEN MANAGEMENT ==============

def generate_jwt_secret_key() -> str:
    """Generate a new JWT secret key and return it as base64."""
    key = os.urandom(32)
    return base64.urlsafe_b64encode(key).decode("ascii")


def get_jwt_secret_key(env_var: str = JWT_SECRET_KEY_ENV_VAR) -> str:
    """
    Get JWT secret key from environment variable.
    
    Args:
        env_var: Environment variable name
        
    Returns:
        JWT secret key
        
    Raises:
        RuntimeError: If JWT secret key not found in environment
    """
    secret = os.environ.get(env_var)
    if not secret:
        raise RuntimeError(f"JWT secret key not found in environment variable '{env_var}'")
    return secret


def create_access_token(
    data: dict,
    expires_delta: Optional[timedelta] = None,
    secret_key: Optional[str] = None
) -> str:
    """
    Create a JWT access token.
    
    Args:
        data: Dictionary containing token payload (should include 'sub', 'role', 'is_verified')
        expires_delta: Optional token expiration time delta
        secret_key: Optional secret key (if not provided, will use environment variable)
        
    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=JWT_ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    
    if secret_key is None:
        secret_key = get_jwt_secret_key()
    
    encoded_jwt = jwt.encode(to_encode, secret_key, algorithm=JWT_ALGORITHM)
    return encoded_jwt


def decode_access_token(token: str, secret_key: Optional[str] = None) -> dict:
    """
    Decode and verify a JWT access token.
    
    Args:
        token: JWT token string
        secret_key: Optional secret key (if not provided, will use environment variable)
        
    Returns:
        Decoded token payload dictionary
        
    Raises:
        JWTError: If token is invalid or expired
    """
    if secret_key is None:
        secret_key = get_jwt_secret_key()
    
    try:
        payload = jwt.decode(token, secret_key, algorithms=[JWT_ALGORITHM])
        return payload
    except JWTError as e:
        raise JWTError(f"Could not validate credentials: {str(e)}") from e



# ========== DEMO ==========
if __name__ == "__main__":    
    print("New master key (put this into your env):", end=" ")  # Generate a new master key (one-time) and manually add it to the environment:
    demo_master_key = generate_master_key_base64()
    print(demo_master_key)    
    set_master_key_in_process(demo_master_key)

    secret = "1BQ:ABCDEFG... (example StringSession)"
    print("Original:", secret)
    
    encrypted = encrypt_secret(secret, purpose=PURPOSE_STRING_SESSION)
    print("Encrypted:", encrypted)

    decrypted = decrypt_secret(encrypted, purpose=PURPOSE_STRING_SESSION)
    print("Decrypted:", decrypted)
