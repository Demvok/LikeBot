import os, base64
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# ============== Configurations ===============
SALT_SIZE = 16                            # bytes for salt in HKDF
NONCE_SIZE = 12                           # bytes for AES-GCM nonce
DEK_LEN = 32                              # 32 bytes -> AES-256
MASTER_KEY_ENV_VAR = "KEK"                # name of the environment variable by default
HKDF_INFO_PREFIX = b"likebot-secret-v1:"  # context (helps to differentiate secret types)
# =============================================

def generate_master_key_base64() -> str:
    """Generate a new master key (32 bytes) and return it as base64 (for easy storage in env)."""
    key = os.urandom(32)
    return base64.urlsafe_b64encode(key).decode("ascii")


def set_master_key_in_process(kek_base64: str, env_var: str = MASTER_KEY_ENV_VAR) -> None:
    """
    Putting master key in os.environ only for the current process.
    For permanent storage use export in shell or secret manager.
    """
    os.environ[env_var] = kek_base64


def get_master_key_bytes_from_env(env_var: str = MASTER_KEY_ENV_VAR) -> bytes:
    """Get master key from environment variable (base64) and decode to bytes. Raises error if not found."""
    b64 = os.environ.get(env_var)
    if not b64:
        raise RuntimeError(f"Master key not found in environment variable '{env_var}'")
    return base64.urlsafe_b64decode(b64.encode("ascii"))


def _derive_dek(master_key: bytes, salt: bytes, purpose: bytes) -> bytes:
    """
    Derive a unique DEK from the master key and salt using HKDF.
    'purpose' differentiates the secret type (e.g. b'StringSession' or b'Password').
    """
    info = HKDF_INFO_PREFIX + purpose
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=DEK_LEN,
        salt=salt,
        info=info,
    )
    return hkdf.derive(master_key)


def encrypt_secret(plaintext: str, purpose: bytes = b"StringSession", master_key_env_var: str = MASTER_KEY_ENV_VAR) -> str:
    """
    Return base64url string containing (salt || nonce || ciphertext).
    purpose - byte marker, to differentiate the secret type when deriving DEK.
    """
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    salt = os.urandom(SALT_SIZE)
    dek = _derive_dek(master_key, salt, purpose)
    aesgcm = AESGCM(dek)
    nonce = os.urandom(NONCE_SIZE)
    ct = aesgcm.encrypt(nonce=nonce, data=plaintext.encode("utf-8"), associated_data=None)
    payload = salt + nonce + ct
    return base64.urlsafe_b64encode(payload).decode("ascii")


def decrypt_secret(token_b64: str, purpose: bytes = b"StringSession", master_key_env_var: str = MASTER_KEY_ENV_VAR) -> str:
    """
    Decrypts a string generated by encrypt_secret. Returns plain text.
    """
    master_key = get_master_key_bytes_from_env(master_key_env_var)
    payload = base64.urlsafe_b64decode(token_b64.encode("ascii"))
    if len(payload) < (SALT_SIZE + NONCE_SIZE + 1):
        raise ValueError("Invalid token length")
    salt = payload[:SALT_SIZE]
    nonce = payload[SALT_SIZE:SALT_SIZE + NONCE_SIZE]
    ct = payload[SALT_SIZE + NONCE_SIZE:]
    dek = _derive_dek(master_key, salt, purpose)
    aesgcm = AESGCM(dek)
    pt = aesgcm.decrypt(nonce=nonce, data=ct, associated_data=None)
    return pt.decode("utf-8")



# ========== DEMO ==========
if __name__ == "__main__":    
    print("New master key (put this into your env):", end=" ")  # Generate a new master key (one-time) and manually add it to the environment:
    demo_master_key = generate_master_key_base64()
    print(demo_master_key)    
    set_master_key_in_process(demo_master_key)

    secret = "1BQ:ABCDEFG... (example StringSession)"
    print("Original:", secret)
    
    encrypted = encrypt_secret(secret, purpose=b"StringSession")
    print("Encrypted:", encrypted)

    decrypted = decrypt_secret(encrypted, purpose=b"StringSession")
    print("Decrypted:", decrypted)
